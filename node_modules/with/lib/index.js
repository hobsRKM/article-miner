'use strict';

exports.__esModule = true;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

exports.default = addWith;

var _babylon = require('babylon');

var _babylonWalk = require('babylon-walk');

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _globals = require('./globals.js');

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var includes = function includes(array, searchElement, fromIndex) {
  return Array.prototype.includes.call(array, searchElement, fromIndex);
};

var parseOptions = {
  allowReturnOutsideFunction: true,
  allowImportExportEverywhere: true
};

/**
 * Mimic `with` as far as possible but at compile time
 *
 * @param {String} obj The object part of a with expression
 * @param {String} src The body of the with expression
 * @param {Array.<String>} exclude A list of variable names to explicitly exclude
 */
function addWith(obj, src) {
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  obj = obj + '';
  src = src + '';

  var ast = void 0;
  try {
    ast = (0, _babylon.parse)(src, parseOptions);
  } catch (e) {
    throw (0, _assign2.default)(new Error('Error parsing body of the with expression'), {
      component: 'src',
      babylonError: e
    });
  }
  var objAst = void 0;
  try {
    objAst = (0, _babylon.parse)(obj, parseOptions);
  } catch (e) {
    throw (0, _assign2.default)(new Error('Error parsing object part of the with expression'), {
      component: 'obj',
      babylonError: e
    });
  }
  exclude = new _set2.default(['undefined', 'this'].concat(exclude, (0, _globals2.default)(objAst).map(function (g) {
    return g.name;
  })));

  var vars = new _set2.default((0, _globals2.default)(ast).map(function (global) {
    return global.name;
  }).filter(function (v) {
    return !exclude.has(v);
  }));

  if (vars.size === 0) return src;

  var declareLocal = '';
  var local = 'locals_for_with';
  var result = 'result_of_with';
  if (t.isValidIdentifier(obj)) {
    local = obj;
  } else {
    while (vars.has(local) || exclude.has(local)) {
      local += '_';
    }
    declareLocal = 'var ' + local + ' = (' + obj + ');';
  }
  while (vars.has(result) || exclude.has(result)) {
    result += '_';
  }

  var args = ['this'].concat((0, _from2.default)(vars).map(function (v) {
    return (0, _stringify2.default)(v) + ' in ' + local + ' ?\n        ' + local + '.' + v + ' :\n        typeof ' + v + ' !== \'undefined\' ? ' + v + ' : undefined';
  }));

  var unwrapped = unwrapReturns(ast, src, result);

  return ';\n    ' + declareLocal + '\n    ' + unwrapped.before + '\n    (function (' + (0, _from2.default)(vars).join(', ') + ') {\n      ' + unwrapped.body + '\n    }.call(' + args.join(', ') + '));\n    ' + unwrapped.after + ';';
}

var unwrapReturnsVisitors = {
  Function: function Function(node, state, c) {
    // returns in these functions are not applicable
  },
  ReturnStatement: function ReturnStatement(node, state) {
    state.hasReturn = true;
    var value = '';
    if (node.argument) {
      value = 'value: (' + state.source(node.argument) + ')';
    }
    state.replace(node, 'return {' + value + '};');
  }
};

/**
 * Take a self calling function, and unwrap it such that return inside the function
 * results in return outside the function
 *
 * @param {String} src    Some JavaScript code representing a self-calling function
 * @param {String} result A temporary variable to store the result in
 */
function unwrapReturns(ast, src, result) {
  var charArray = src.split('');

  var state = {
    hasReturn: false,
    source: function source(node) {
      return src.slice(node.start, node.end);
    },
    replace: function replace(node, str) {
      charArray.fill('', node.start, node.end);
      charArray[node.start] = str;
    }
  };

  (0, _babylonWalk.recursive)(ast, unwrapReturnsVisitors, state);

  return {
    before: state.hasReturn ? 'var ' + result + ' = ' : '',
    body: charArray.join(''),
    after: state.hasReturn ? ';if (' + result + ') return ' + result + '.value' : ''
  };
}
module.exports = exports['default'];