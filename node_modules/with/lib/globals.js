'use strict';

exports.__esModule = true;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

exports.default = findGlobals;

var _babylonWalk = require('babylon-walk');

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _reference = require('./reference.js');

var _reference2 = _interopRequireDefault(_reference);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isScope = t.isFunctionParent;
var isBlockScope = function isBlockScope(node) {
  return t.isBlockStatement(node) || isScope(node);
};

var declaresArguments = function declaresArguments(node) {
  return t.isFunction(node) && !t.isArrowFunctionExpression(node);
};
var declaresThis = declaresArguments;

var LOCALS_SYMBOL = (0, _symbol2.default)('locals');
var declareLocal = function declareLocal(node) {
  return node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new _set2.default();
};
var setLocal = function setLocal(node, name) {
  return declareLocal(node).add(name);
};

// First pass

function declareFunction(node) {
  for (var _iterator = node.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var param = _ref;

    declarePattern(param, node);
  }
  if (node.id) {
    setLocal(node, node.id.name);
  }
}

function declarePattern(node, parent) {
  switch (node.type) {
    case 'Identifier':
      setLocal(parent, node.name);
      break;
    case 'ObjectPattern':
      for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        declarePattern(prop.value, parent);
      }
      break;
    case 'ArrayPattern':
      for (var _iterator3 = node.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var element = _ref3;

        if (element) declarePattern(element, parent);
      }
      break;
    case 'RestElement':
      declarePattern(node.argument, parent);
      break;
    case 'AssignmentPattern':
      declarePattern(node.left, parent);
      break;
    // istanbul ignore next
    default:
      throw new Error('Unrecognized pattern type: ' + node.type);
  }
}

function declareModuleSpecifier(node, state, parents) {
  setLocal(parents[1], node.local.name);
}

var firstPass = {
  VariableDeclaration: function VariableDeclaration(node, state, parents) {
    var parent = void 0;
    for (var i = parents.length - 2; i >= 0 && !parent; i--) {
      if (node.kind === 'var' ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {
        parent = parents[i];
      }
    }
    for (var _iterator4 = node.declarations, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var declaration = _ref4;

      declarePattern(declaration.id, parent);
    }
  },
  FunctionDeclaration: function FunctionDeclaration(node, state, parents) {
    var parent = void 0;
    for (var i = parents.length - 2; i >= 0 && !parent; i--) {
      if (isScope(parents[i])) {
        parent = parents[i];
      }
    }
    setLocal(parent, node.id.name);
    declareFunction(node);
  },

  Function: declareFunction,
  ClassDeclaration: function ClassDeclaration(node, state, parents) {
    var parent = void 0;
    for (var i = parents.length - 2; i >= 0 && !parent; i--) {
      if (isScope(parents[i])) {
        parent = parents[i];
      }
    }
    setLocal(parent, node.id.name);
  },
  TryStatement: function TryStatement(node) {
    if (node.handler === null) return;
    setLocal(node.handler, node.handler.param.name);
  },

  ImportDefaultSpecifier: declareModuleSpecifier,
  ImportSpecifier: declareModuleSpecifier,
  ImportNamespaceSpecifier: declareModuleSpecifier
};

// Second pass

var secondPass = {
  Identifier: function Identifier(node, state, parents) {
    var name = node.name;
    if (name === 'undefined') return;

    var lastParent = parents[parents.length - 2];
    if (lastParent) {
      if (!(0, _reference2.default)(node, lastParent)) return;

      var parent = void 0;
      for (var _iterator5 = parents, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
        var _ref5;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref5 = _i5.value;
        }

        var _parent = _ref5;

        if (name === 'arguments' && declaresArguments(_parent)) {
          return;
        }
        if (_parent[LOCALS_SYMBOL] && _parent[LOCALS_SYMBOL].has(name)) {
          return;
        }
      }
    }
    state.globals.push(node);
  },
  ThisExpression: function ThisExpression(node, state, parents) {
    for (var _iterator6 = parents, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
      var _ref6;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref6 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref6 = _i6.value;
      }

      var parent = _ref6;

      if (declaresThis(parents)) {
        return;
      }
    }
    state.globals.push(node);
  }
};

function findGlobals(ast) {
  var globals = [];
  // istanbul ignore if
  if (!t.isNode(ast)) {
    throw new TypeError('Source must be a Babylon AST');
  }
  (0, _babylonWalk.ancestor)(ast, firstPass);
  (0, _babylonWalk.ancestor)(ast, secondPass, { globals: globals });
  var groupedGlobals = (0, _create2.default)(null);
  for (var _iterator7 = globals, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
    var _ref7;

    if (_isArray7) {
      if (_i7 >= _iterator7.length) break;
      _ref7 = _iterator7[_i7++];
    } else {
      _i7 = _iterator7.next();
      if (_i7.done) break;
      _ref7 = _i7.value;
    }

    var node = _ref7;

    var name = node.type === 'ThisExpression' ? 'this' : node.name;
    groupedGlobals[name] = groupedGlobals[name] || [];
    groupedGlobals[name].push(node);
  }
  return (0, _keys2.default)(groupedGlobals).sort().map(function (name) {
    return { name: name, nodes: groupedGlobals[name] };
  });
}
module.exports = exports['default'];