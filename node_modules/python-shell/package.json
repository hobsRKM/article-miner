{
  "_from": "python-shell",
  "_id": "python-shell@1.0.8",
  "_inBundle": false,
  "_integrity": "sha512-jMKagerg3alm6j+Prq5t/M3dTgEppy5vC6ns+LqAjfuHiT8olfK3PMokpqpeEcWEqvDnUcAOhp6SQzaLBtTzRw==",
  "_location": "/python-shell",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "python-shell",
    "fetchSpec": "latest",
    "name": "python-shell",
    "raw": "python-shell",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/python-shell/-/python-shell-1.0.8.tgz",
  "_shasum": "067bc93d790913efaa4b2a3c9d0e85e02adab510",
  "_spec": "python-shell",
  "_where": "/var/www/html/media_image",
  "author": {
    "email": "nicolas@extrabacon.net",
    "name": "Nicolas Mercier"
  },
  "bugs": {
    "url": "http://github.com/extrabacon/python-shell/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "Run Python scripts from Node.js with simple (but efficient) inter-process communication through stdio",
  "devDependencies": {
    "@types/mocha": "^5.2.5",
    "@types/node": "^9.3.0",
    "mocha": "^5.2.0",
    "mocha-appveyor-reporter": "^0.4.0",
    "should": "^13.2.1",
    "ts-node": "^7.0.1",
    "typescript": "^3.0.1"
  },
  "engines": {
    "node": ">=0.10"
  },
  "files": [
    "*.d.ts",
    "*.js",
    "*.js.map",
    "CHANGELOG.md",
    "README.md"
  ],
  "homepage": "http://github.com/extrabacon/python-shell",
  "keywords": [
    "python"
  ],
  "license": "MIT",
  "name": "python-shell",
  "optionalDependencies": {},
  "readme": "# [python-shell](https://www.npmjs.com/package/python-shell) [![Build status](https://ci.appveyor.com/api/projects/status/m8e3h53vvxg5wb2q?svg=true)](https://ci.appveyor.com/project/Almenon/python-shell) [![codecov](https://codecov.io/gh/extrabacon/python-shell/branch/master/graph/badge.svg)](https://codecov.io/gh/extrabacon/python-shell)\r\n\r\n<!-- chage above url accroding to repo -->\r\nA simple way to run Python scripts from Node.js with basic but efficient inter-process communication and better error handling.\r\n\r\n## Features\r\n\r\n+ Reliably spawn Python scripts in a child process\r\n+ Built-in text, JSON and binary modes\r\n+ Custom parsers and formatters\r\n+ Simple and efficient data transfers through stdin and stdout streams\r\n+ Extended stack traces when an error is thrown\r\n\r\n## Installation\r\n\r\n```bash\r\nnpm install python-shell\r\n```\r\n\r\nTo run the tests:\r\n```bash\r\nnpm test\r\n```\r\n\r\n## Documentation\r\n\r\n### Running python code:\r\n\r\n```typescript\r\nimport {PythonShell} from 'python-shell';\r\n\r\nPythonShell.runString('x=1+1;print(x)', null, function (err) {\r\n  if (err) throw err;\r\n  console.log('finished');\r\n});\r\n```\r\n\r\nIf the script exits with a non-zero code, an error will be thrown.\r\n\r\nNote the use of imports! If you're not using typescript ಠ_ಠ you can [still get imports to work with this guide](https://github.com/extrabacon/python-shell/issues/148#issuecomment-419120209).\r\n\r\nOr you can use require like so: \r\n```javascript\r\nlet {PythonShell} = require('python-shell')\r\n```\r\n\r\n### Running a Python script:\r\n\r\n```typescript\r\nimport {PythonShell} from 'python-shell';\r\n\r\nPythonShell.run('my_script.py', null, function (err) {\r\n  if (err) throw err;\r\n  console.log('finished');\r\n});\r\n```\r\n\r\nIf the script exits with a non-zero code, an error will be thrown.\r\n\r\n### Running a Python script with arguments and options:\r\n\r\n```typescript\r\nimport {PythonShell} from 'python-shell';\r\n\r\nlet options = {\r\n  mode: 'text',\r\n  pythonPath: 'path/to/python',\r\n  pythonOptions: ['-u'], // get print results in real-time\r\n  scriptPath: 'path/to/my/scripts',\r\n  args: ['value1', 'value2', 'value3']\r\n};\r\n\r\nPythonShell.run('my_script.py', options, function (err, results) {\r\n  if (err) throw err;\r\n  // results is an array consisting of messages collected during execution\r\n  console.log('results: %j', results);\r\n});\r\n```\r\n\r\n### Exchanging data between Node and Python:\r\n\r\n```typescript\r\nimport {PythonShell} from 'python-shell';\r\nlet pyshell = new PythonShell('my_script.py');\r\n\r\n// sends a message to the Python script via stdin\r\npyshell.send('hello');\r\n\r\npyshell.on('message', function (message) {\r\n  // received a message sent from the Python script (a simple \"print\" statement)\r\n  console.log(message);\r\n});\r\n\r\n// end the input stream and allow the process to exit\r\npyshell.end(function (err,code,signal) {\r\n  if (err) throw err;\r\n  console.log('The exit code was: ' + code);\r\n  console.log('The exit signal was: ' + signal);\r\n  console.log('finished');\r\n  console.log('finished');\r\n});\r\n```\r\n\r\nUse `.send(message)` to send a message to the Python script. Attach the `message` event to listen to messages emitted from the Python script.\r\n\r\nUse `options.mode` to quickly setup how data is sent and received between your Node and Python applications.\r\n\r\n  * use `text` mode for exchanging lines of text\r\n  * use `json` mode for exchanging JSON fragments\r\n  * use `binary` mode for anything else (data is sent and received as-is)\r\n\r\nFor more details and examples including Python source code, take a look at the tests.\r\n\r\n### Error Handling and extended stack traces\r\n\r\nAn error will be thrown if the process exits with a non-zero exit code. Additionally, if \"stderr\" contains a formatted Python traceback, the error is augmented with Python exception details including a concatenated stack trace.\r\n\r\nSample error with traceback (from test/python/error.py):\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"test/python/error.py\", line 6, in <module>\r\n    divide_by_zero()\r\n  File \"test/python/error.py\", line 4, in divide_by_zero\r\n    print 1/0\r\nZeroDivisionError: integer division or modulo by zero\r\n```\r\n\r\nwould result into the following error:\r\n\r\n```typescript\r\n{ [Error: ZeroDivisionError: integer division or modulo by zero]\r\n  traceback: 'Traceback (most recent call last):\\n  File \"test/python/error.py\", line 6, in <module>\\n    divide_by_zero()\\n  File \"test/python/error.py\", line 4, in divide_by_zero\\n    print 1/0\\nZeroDivisionError: integer division or modulo by zero\\n',\r\n  executable: 'python',\r\n  options: null,\r\n  script: 'test/python/error.py',\r\n  args: null,\r\n  exitCode: 1 }\r\n```\r\n\r\nand `err.stack` would look like this:\r\n\r\n```\r\nError: ZeroDivisionError: integer division or modulo by zero\r\n    at PythonShell.parseError (python-shell/index.js:131:17)\r\n    at ChildProcess.<anonymous> (python-shell/index.js:67:28)\r\n    at ChildProcess.EventEmitter.emit (events.js:98:17)\r\n    at Process.ChildProcess._handle.onexit (child_process.js:797:12)\r\n    ----- Python Traceback -----\r\n    File \"test/python/error.py\", line 6, in <module>\r\n      divide_by_zero()\r\n    File \"test/python/error.py\", line 4, in divide_by_zero\r\n      print 1/0\r\n```\r\n\r\n## API Reference\r\n\r\n#### `PythonShell(script, options)` constructor\r\n\r\nCreates an instance of `PythonShell` and starts the Python process\r\n\r\n* `script`: the path of the script to execute\r\n* `options`: the execution options, consisting of:\r\n  * `mode`: Configures how data is exchanged when data flows through stdin and stdout. The possible values are:\r\n    * `text`: each line of data (ending with \"\\n\") is emitted as a message (default)\r\n    * `json`: each line of data (ending with \"\\n\") is parsed as JSON and emitted as a message\r\n    * `binary`: data is streamed as-is through `stdout` and `stdin`\r\n  * `formatter`: each message to send is transformed using this method, then appended with \"\\n\"\r\n  * `parser`: each line of data (ending with \"\\n\") is parsed with this function and its result is emitted as a message\r\n  * `stderrParser`: each line of logs (ending with \"\\n\") is parsed with this function and its result is emitted as a message\r\n  * `encoding`: the text encoding to apply on the child process streams (default: \"utf8\")\r\n  * `pythonPath`: The path where to locate the \"python\" executable. Default: \"python\"\r\n  * `pythonOptions`: Array of option switches to pass to \"python\"\r\n  * `scriptPath`: The default path where to look for scripts. Default is the current working directory.\r\n  * `args`: Array of arguments to pass to the script\r\n\r\nOther options are forwarded to `child_process.spawn`.\r\n\r\nPythonShell instances have the following properties:\r\n* `script`: the path of the script to execute\r\n* `command`: the full command arguments passed to the Python executable\r\n* `stdin`: the Python stdin stream, used to send data to the child process\r\n* `stdout`: the Python stdout stream, used for receiving data from the child process\r\n* `stderr`: the Python stderr stream, used for communicating logs & errors\r\n* `childProcess`: the process instance created via `child_process.spawn`\r\n* `terminated`: boolean indicating whether the process has exited\r\n* `exitCode`: the process exit code, available after the process has ended\r\n\r\nExample:\r\n\r\n```typescript\r\n// create a new instance\r\nlet shell = new PythonShell('script.py', options);\r\n```\r\n\r\n#### `#defaultOptions`\r\n\r\nConfigures default options for all new instances of PythonShell.\r\n\r\nExample:\r\n\r\n```typescript\r\n// setup a default \"scriptPath\"\r\nPythonShell.defaultOptions = { scriptPath: '../scripts' };\r\n```\r\n\r\n#### `#run(script, options, callback)`\r\n\r\nRuns the Python script and invokes `callback` with the results. The callback contains the execution error (if any) as well as an array of messages emitted from the Python script.\r\n\r\nThis method is also returning the `PythonShell` instance.\r\n\r\nExample:\r\n\r\n```typescript\r\n// run a simple script\r\nPythonShell.run('script.py', null, function (err, results) {\r\n  // script finished\r\n});\r\n```\r\n\r\n#### `#runString(code, options, callback)`\r\n\r\nRuns the Python code and invokes `callback` with the results. The callback contains the execution error (if any) as well as an array of messages emitted from the Python script.\r\n\r\nThis method is also returning the `PythonShell` instance.\r\n\r\nExample:\r\n\r\n```typescript\r\n// run a simple script\r\nPythonShell.runString('x=1;print(x)', null, function (err, results) {\r\n  // script finished\r\n});\r\n```\r\n\r\n#### `#checkSyntax(code:string)`\r\n\r\nChecks the syntax of the code and returns a promise.\r\nPromise is rejected if there is a syntax error.\r\n\r\n#### `#checkSyntaxFile(filePath:string)`\r\n\r\nChecks the syntax of the file and returns a promise.\r\nPromise is rejected if there is a syntax error.\r\n\r\n#### `#getVersion(pythonPath?:string)`\r\n\r\nReturns the python version. Optional pythonPath param to get the version \r\nof a specific python interpreter.\r\n\r\n#### `#getVersionSync(pythonPath?:string)`\r\n\r\nReturns the python version. Optional pythonPath param to get the version \r\nof a specific python interpreter.\r\n\r\n#### `.send(message)`\r\n\r\nSends a message to the Python script via stdin. The data is formatted according to the selected mode (text or JSON), or through a custom function when `formatter` is specified.\r\n\r\nExample:\r\n\r\n```typescript\r\n// send a message in text mode\r\nlet shell = new PythonShell('script.py', { mode: 'text '});\r\nshell.send('hello world!');\r\n\r\n// send a message in JSON mode\r\nlet shell = new PythonShell('script.py', { mode: 'json '});\r\nshell.send({ command: \"do_stuff\", args: [1, 2, 3] });\r\n```\r\n\r\n#### `.receive(data)`\r\n\r\nParses incoming data from the Python script written via stdout and emits `message` events. This method is called automatically as data is being received from stdout.\r\n\r\n#### `.receiveStderr(data)`\r\n\r\nParses incoming logs from the Python script written via stderr and emits `stderr` events. This method is called automatically as data is being received from stderr.\r\n\r\n#### `.end(callback)`\r\n\r\nCloses the stdin stream, allowing the Python script to finish and exit. The optional callback is invoked when the process is terminated.\r\n\r\n#### `.terminate(signal)`\r\n\r\nTerminates the python script, the optional end callback is invoked if specified. A kill signal may be provided by `signal`, if `signal` is not specified SIGTERM is sent.\r\n\r\n#### event: `message`\r\n\r\nFires when a chunk of data is parsed from the stdout stream via the `receive` method. If a `parser` method is specified, the result of this function will be the message value. This event is not emitted in binary mode.\r\n\r\nExample:\r\n\r\n```typescript\r\n// receive a message in text mode\r\nlet shell = new PythonShell('script.py', { mode: 'text '});\r\nshell.on('message', function (message) {\r\n  // handle message (a line of text from stdout)\r\n});\r\n\r\n// receive a message in JSON mode\r\nlet shell = new PythonShell('script.py', { mode: 'json '});\r\nshell.on('message', function (message) {\r\n  // handle message (a line of text from stdout, parsed as JSON)\r\n});\r\n```\r\n\r\n#### event: `stderr`\r\n\r\nFires when a chunk of logs is parsed from the stderr stream via the `receiveStderr` method. If a `stderrParser` method is specified, the result of this function will be the message value. This event is not emitted in binary mode.\r\n\r\nExample:\r\n\r\n```typescript\r\n// receive a message in text mode\r\nlet shell = new PythonShell('script.py', { mode: 'text '});\r\nshell.on('stderr', function (stderr) {\r\n  // handle stderr (a line of text from stderr)\r\n});\r\n```\r\n\r\n#### event: `close`\r\n\r\nFires when the process has been terminated, with an error or not.\r\n\r\n#### event: `error`\r\n\r\nFires when the process terminates with a non-zero exit code.\r\n\r\n## Used By:\r\n\r\nPython-Shell is used by [arepl-vscode](https://github.com/almenon/arepl-vscode), [gitinspector](https://github.com/ejwa/gitinspector), [pyspreadsheet](https://github.com/extrabacon/pyspreadsheet), and more!\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 Nicolas Mercier\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/extrabacon/python-shell.git"
  },
  "scripts": {
    "appveyorTest": "tsc -p ./ && nyc mocha --reporter mocha-appveyor-reporter test/*.js",
    "compile": "tsc -watch -p ./",
    "test": "tsc -p ./ && mocha"
  },
  "version": "1.0.8"
}
